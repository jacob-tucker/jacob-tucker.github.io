<!DOCTYPE HTML>
<html>

    <head>

        <title>Jacob Tucker</title>

        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel='stylesheet' href='../main.css'>
        <link rel='stylesheet' href='./projects.css'>
        <script type='text/javascript' src='../main.js'></script>

    </head>

    <body>

        <div class='nav_bar'>

            <div class='nav_bar_element nav_bar_left'>
                <h2><a href='../index.html'>-JT-</a></h2>
            </div>

            <div class='nav_bar_element nav_bar_right'>
                <div class='page_links'>
                    <a href='../index.html'><p>01.</p><h4>ABOUT ME</h4></a>
                    <a href='./projects.html'><p>02.</p><h4>PROJECTS</h4></a>
                    <a><p>03.</p><h4>CONTACT</h4></a>
                    <a><p>04.</p><h4>RESUME</h4></a>
                </div>
            </div>

        </div>
        <div>
          <a class="arrow2" href='./projects.html'><img src='../gifs/arrow.png' /></a>
        </div>
        <div class="project1">
          <h2>Search Algorithm Tool</h2>
          <p>July 2020</p>
          <img src="../gifs/searchalg.gif" />
          <div class="summaryBlock">
            <h3>Summary</h3>
            <p>I built a search algorithm web app that helps users learn about graph search algorithms such as Dijkstra's and
            A*, with built in tools such as auto-generating mazes, the ability to add walls, and more.</p>

            <p id="code">React HTML CSS Javascript</p>
          </div>
          <div class="highlights">
            <h2>KEY POINTS</h2>
            <p>•Used React.js to combine the style and formatting of the HTML & CSS with the graph-search and maze creating
            algorithms, which were written in Javascript.</p>
            <p>•Implemented React.js using hooks that handeled the state of the walls, the nodes currently being searched,
              the discovered nodes, and the start & end points simultaneously.</p>
            <p>•Wrote 5 graph traversal algorithms, including A*, Dijkstra (w and w/o a Binary Heap),
              Greedy Best-First Search, and Depth-First Search using priority queues and other data structures.</p>
            <p>•Programmed a maze generator using recursive divison along with a random maze generator.</p>
          </div>
          <div class="description">
            <h2>DESCRIPTION</h2>
            <p>As I entered the Summer of 2020, I had just completed my first year of Computer Science at Northwestern.
            I knew I was extremely interested in Computer Science, and I wanted to test my skills to see if I had what it takes,
            having no idea what real computer science was all about. I ended up sitting down one day trying to find a project
            idea and hopefully implement it over the next few weeks. After seeing many different ideas online and not
            liking the vast majority, I decided to test my fate with this graph-search algorithm tool.</p>

            <p>The reason a sort of "tool" grabbed my eye was because I've always wanted to try and look into how
            programmers can help other programmers get into the field. Sometimes it is daunting to hear the words
            used by Computer Scientists, and especially after having just taken a class on Data Structures in the Spring,
            I knew how difficult it could be. Second, because I knew I wanted to continue on my web programming path,
            I knew this project could combine HTML, CSS, and JS with React in the perfect way.</p>

            <p>This project allows users to choose any algorithm they want and watch it run. The application shows the user
            when it is discovering a node in real-time and then proceeds to show the "shortest" path (whether or not the
            algorithm guarentees a shortest path is also explained to the user). A help menu is provided to explain any
            difficult vocabulary, such as "weighted" and "unweighted" algorithms.</p>

            <p>To make things more clear, the user can add walls with a click of the mouse or drag the mouse across the board.
            This way, the user can truly see the power/weaknesses of each algorithm in how they deal with weights (or walls).
            The user also has the ability to move the start and end node around to test more use cases.</p>
          </div>
      </div>
    </body>

</html>
